/*
Blog Post endpoints

\"Use these endpoints for interacting with Blog Posts, Blog Authors, and Blog Tags\"

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package blog_posts

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"

	"github.com/clarkmcc/go-hubspot/authorization"
	_neturl "net/url"
	"reflect"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// BlogPostApiService BlogPostApi service
type BlogPostApiService service

type ApiDeleteCmsV3BlogsPostsObjectIdArchiveRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	objectId   string
	archived   *bool
}

// Whether to return only results that have been archived.
func (r ApiDeleteCmsV3BlogsPostsObjectIdArchiveRequest) Archived(archived bool) ApiDeleteCmsV3BlogsPostsObjectIdArchiveRequest {
	r.archived = &archived
	return r
}

func (r ApiDeleteCmsV3BlogsPostsObjectIdArchiveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteCmsV3BlogsPostsObjectIdArchiveExecute(r)
}

/*
DeleteCmsV3BlogsPostsObjectIdArchive Delete a Blog Post

Delete the Blog Post object identified by the id in the path.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Post id.
 @return ApiDeleteCmsV3BlogsPostsObjectIdArchiveRequest
*/
func (a *BlogPostApiService) DeleteCmsV3BlogsPostsObjectIdArchive(ctx _context.Context, objectId string) ApiDeleteCmsV3BlogsPostsObjectIdArchiveRequest {
	return ApiDeleteCmsV3BlogsPostsObjectIdArchiveRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
func (a *BlogPostApiService) DeleteCmsV3BlogsPostsObjectIdArchiveExecute(r ApiDeleteCmsV3BlogsPostsObjectIdArchiveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.DeleteCmsV3BlogsPostsObjectIdArchive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogsPostsGetPageRequest struct {
	ctx           _context.Context
	ApiService    *BlogPostApiService
	createdAt     *time.Time
	createdAfter  *time.Time
	createdBefore *time.Time
	updatedAt     *time.Time
	updatedAfter  *time.Time
	updatedBefore *time.Time
	sort          *[]string
	after         *string
	limit         *int32
	archived      *bool
}

// Only return Blog Posts created at exactly the specified time.
func (r ApiGetCmsV3BlogsPostsGetPageRequest) CreatedAt(createdAt time.Time) ApiGetCmsV3BlogsPostsGetPageRequest {
	r.createdAt = &createdAt
	return r
}

// Only return Blog Posts created after the specified time.
func (r ApiGetCmsV3BlogsPostsGetPageRequest) CreatedAfter(createdAfter time.Time) ApiGetCmsV3BlogsPostsGetPageRequest {
	r.createdAfter = &createdAfter
	return r
}

// Only return Blog Posts created before the specified time.
func (r ApiGetCmsV3BlogsPostsGetPageRequest) CreatedBefore(createdBefore time.Time) ApiGetCmsV3BlogsPostsGetPageRequest {
	r.createdBefore = &createdBefore
	return r
}

// Only return Blog Posts last updated at exactly the specified time.
func (r ApiGetCmsV3BlogsPostsGetPageRequest) UpdatedAt(updatedAt time.Time) ApiGetCmsV3BlogsPostsGetPageRequest {
	r.updatedAt = &updatedAt
	return r
}

// Only return Blog Posts last updated after the specified time.
func (r ApiGetCmsV3BlogsPostsGetPageRequest) UpdatedAfter(updatedAfter time.Time) ApiGetCmsV3BlogsPostsGetPageRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Only return Blog Posts last updated before the specified time.
func (r ApiGetCmsV3BlogsPostsGetPageRequest) UpdatedBefore(updatedBefore time.Time) ApiGetCmsV3BlogsPostsGetPageRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Specifies which fields to use for sorting results. Valid fields are &#x60;name&#x60;, &#x60;createdAt&#x60;, &#x60;updatedAt&#x60;, &#x60;createdBy&#x60;, &#x60;updatedBy&#x60;. &#x60;createdAt&#x60; will be used by default.
func (r ApiGetCmsV3BlogsPostsGetPageRequest) Sort(sort []string) ApiGetCmsV3BlogsPostsGetPageRequest {
	r.sort = &sort
	return r
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3BlogsPostsGetPageRequest) After(after string) ApiGetCmsV3BlogsPostsGetPageRequest {
	r.after = &after
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3BlogsPostsGetPageRequest) Limit(limit int32) ApiGetCmsV3BlogsPostsGetPageRequest {
	r.limit = &limit
	return r
}

// Specifies whether to return archived Blog Posts. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3BlogsPostsGetPageRequest) Archived(archived bool) ApiGetCmsV3BlogsPostsGetPageRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3BlogsPostsGetPageRequest) Execute() (CollectionResponseWithTotalBlogPostForwardPaging, *_nethttp.Response, error) {
	return r.ApiService.GetCmsV3BlogsPostsGetPageExecute(r)
}

/*
GetCmsV3BlogsPostsGetPage Get all Blog Posts

Get the list of blog posts. Supports paging and filtering. This method would be useful for an integration that examined these models and used an external service to suggest edits.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCmsV3BlogsPostsGetPageRequest
*/
func (a *BlogPostApiService) GetCmsV3BlogsPostsGetPage(ctx _context.Context) ApiGetCmsV3BlogsPostsGetPageRequest {
	return ApiGetCmsV3BlogsPostsGetPageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalBlogPostForwardPaging
func (a *BlogPostApiService) GetCmsV3BlogsPostsGetPageExecute(r ApiGetCmsV3BlogsPostsGetPageRequest) (CollectionResponseWithTotalBlogPostForwardPaging, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionResponseWithTotalBlogPostForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.GetCmsV3BlogsPostsGetPage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.createdAt != nil {
		localVarQueryParams.Add("createdAt", parameterToString(*r.createdAt, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.updatedAt != nil {
		localVarQueryParams.Add("updatedAt", parameterToString(*r.updatedAt, ""))
	}
	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.updatedBefore != nil {
		localVarQueryParams.Add("updatedBefore", parameterToString(*r.updatedBefore, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.after != nil {
		localVarQueryParams.Add("after", parameterToString(*r.after, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogsPostsObjectIdDraftGetDraftByIdRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	objectId   string
}

func (r ApiGetCmsV3BlogsPostsObjectIdDraftGetDraftByIdRequest) Execute() (BlogPost, *_nethttp.Response, error) {
	return r.ApiService.GetCmsV3BlogsPostsObjectIdDraftGetDraftByIdExecute(r)
}

/*
GetCmsV3BlogsPostsObjectIdDraftGetDraftById Retrieve the full draft version of the Blog Post

Retrieve the full draft version of the Blog Post.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Post id.
 @return ApiGetCmsV3BlogsPostsObjectIdDraftGetDraftByIdRequest
*/
func (a *BlogPostApiService) GetCmsV3BlogsPostsObjectIdDraftGetDraftById(ctx _context.Context, objectId string) ApiGetCmsV3BlogsPostsObjectIdDraftGetDraftByIdRequest {
	return ApiGetCmsV3BlogsPostsObjectIdDraftGetDraftByIdRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
//  @return BlogPost
func (a *BlogPostApiService) GetCmsV3BlogsPostsObjectIdDraftGetDraftByIdExecute(r ApiGetCmsV3BlogsPostsObjectIdDraftGetDraftByIdRequest) (BlogPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.GetCmsV3BlogsPostsObjectIdDraftGetDraftById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/{objectId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogsPostsObjectIdGetByIdRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	objectId   string
	archived   *bool
}

// Specifies whether to return archived Blog Posts. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3BlogsPostsObjectIdGetByIdRequest) Archived(archived bool) ApiGetCmsV3BlogsPostsObjectIdGetByIdRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3BlogsPostsObjectIdGetByIdRequest) Execute() (BlogPost, *_nethttp.Response, error) {
	return r.ApiService.GetCmsV3BlogsPostsObjectIdGetByIdExecute(r)
}

/*
GetCmsV3BlogsPostsObjectIdGetById Retrieve a Blog Post

Retrieve the Blog Post object identified by the id in the path.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Post id.
 @return ApiGetCmsV3BlogsPostsObjectIdGetByIdRequest
*/
func (a *BlogPostApiService) GetCmsV3BlogsPostsObjectIdGetById(ctx _context.Context, objectId string) ApiGetCmsV3BlogsPostsObjectIdGetByIdRequest {
	return ApiGetCmsV3BlogsPostsObjectIdGetByIdRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
//  @return BlogPost
func (a *BlogPostApiService) GetCmsV3BlogsPostsObjectIdGetByIdExecute(r ApiGetCmsV3BlogsPostsObjectIdGetByIdRequest) (BlogPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.GetCmsV3BlogsPostsObjectIdGetById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	objectId   string
	after      *string
	before     *string
	limit      *int32
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest) After(after string) ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest {
	r.after = &after
	return r
}
func (r ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest) Before(before string) ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest {
	r.before = &before
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest) Limit(limit int32) ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest) Execute() (CollectionResponseWithTotalVersionBlogPost, *_nethttp.Response, error) {
	return r.ApiService.GetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsExecute(r)
}

/*
GetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersions Retrieves all the previous versions of a blog post

Retrieves all the previous versions of a blog post.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Post id.
 @return ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest
*/
func (a *BlogPostApiService) GetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersions(ctx _context.Context, objectId string) ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest {
	return ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalVersionBlogPost
func (a *BlogPostApiService) GetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsExecute(r ApiGetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersionsRequest) (CollectionResponseWithTotalVersionBlogPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionResponseWithTotalVersionBlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.GetCmsV3BlogsPostsObjectIdRevisionsGetPreviousVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/{objectId}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.after != nil {
		localVarQueryParams.Add("after", parameterToString(*r.after, ""))
	}
	if r.before != nil {
		localVarQueryParams.Add("before", parameterToString(*r.before, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogsPostsObjectIdRevisionsRevisionIdGetPreviousVersionRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	objectId   string
	revisionId string
}

func (r ApiGetCmsV3BlogsPostsObjectIdRevisionsRevisionIdGetPreviousVersionRequest) Execute() (VersionBlogPost, *_nethttp.Response, error) {
	return r.ApiService.GetCmsV3BlogsPostsObjectIdRevisionsRevisionIdGetPreviousVersionExecute(r)
}

/*
GetCmsV3BlogsPostsObjectIdRevisionsRevisionIdGetPreviousVersion Retrieves a previous version of a blog post

Retrieves a previous version of a blog post.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Post id.
 @param revisionId The Blog Post version id.
 @return ApiGetCmsV3BlogsPostsObjectIdRevisionsRevisionIdGetPreviousVersionRequest
*/
func (a *BlogPostApiService) GetCmsV3BlogsPostsObjectIdRevisionsRevisionIdGetPreviousVersion(ctx _context.Context, objectId string, revisionId string) ApiGetCmsV3BlogsPostsObjectIdRevisionsRevisionIdGetPreviousVersionRequest {
	return ApiGetCmsV3BlogsPostsObjectIdRevisionsRevisionIdGetPreviousVersionRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return VersionBlogPost
func (a *BlogPostApiService) GetCmsV3BlogsPostsObjectIdRevisionsRevisionIdGetPreviousVersionExecute(r ApiGetCmsV3BlogsPostsObjectIdRevisionsRevisionIdGetPreviousVersionRequest) (VersionBlogPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VersionBlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.GetCmsV3BlogsPostsObjectIdRevisionsRevisionIdGetPreviousVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/{objectId}/revisions/{revisionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", _neturl.PathEscape(parameterToString(r.revisionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCmsV3BlogsPostsObjectIdDraftUpdateDraftRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	objectId   string
	blogPost   *BlogPost
}

// The JSON representation of the updated Blog Post to be applied to the draft.
func (r ApiPatchCmsV3BlogsPostsObjectIdDraftUpdateDraftRequest) BlogPost(blogPost BlogPost) ApiPatchCmsV3BlogsPostsObjectIdDraftUpdateDraftRequest {
	r.blogPost = &blogPost
	return r
}

func (r ApiPatchCmsV3BlogsPostsObjectIdDraftUpdateDraftRequest) Execute() (BlogPost, *_nethttp.Response, error) {
	return r.ApiService.PatchCmsV3BlogsPostsObjectIdDraftUpdateDraftExecute(r)
}

/*
PatchCmsV3BlogsPostsObjectIdDraftUpdateDraft Update a Blog Post draft

Sparse updates the draft version of a single Blog Post object identified by the id in the path.
All the column values need not be specified. Only the that need to be modified can be specified.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Post id.
 @return ApiPatchCmsV3BlogsPostsObjectIdDraftUpdateDraftRequest
*/
func (a *BlogPostApiService) PatchCmsV3BlogsPostsObjectIdDraftUpdateDraft(ctx _context.Context, objectId string) ApiPatchCmsV3BlogsPostsObjectIdDraftUpdateDraftRequest {
	return ApiPatchCmsV3BlogsPostsObjectIdDraftUpdateDraftRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
//  @return BlogPost
func (a *BlogPostApiService) PatchCmsV3BlogsPostsObjectIdDraftUpdateDraftExecute(r ApiPatchCmsV3BlogsPostsObjectIdDraftUpdateDraftRequest) (BlogPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PatchCmsV3BlogsPostsObjectIdDraftUpdateDraft")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/{objectId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.blogPost == nil {
		return localVarReturnValue, nil, reportError("blogPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blogPost
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCmsV3BlogsPostsObjectIdUpdateRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	objectId   string
	blogPost   *BlogPost
	archived   *bool
}

// The JSON representation of the updated Blog Post.
func (r ApiPatchCmsV3BlogsPostsObjectIdUpdateRequest) BlogPost(blogPost BlogPost) ApiPatchCmsV3BlogsPostsObjectIdUpdateRequest {
	r.blogPost = &blogPost
	return r
}

// Specifies whether to update archived Blog Posts. Defaults to &#x60;false&#x60;.
func (r ApiPatchCmsV3BlogsPostsObjectIdUpdateRequest) Archived(archived bool) ApiPatchCmsV3BlogsPostsObjectIdUpdateRequest {
	r.archived = &archived
	return r
}

func (r ApiPatchCmsV3BlogsPostsObjectIdUpdateRequest) Execute() (BlogPost, *_nethttp.Response, error) {
	return r.ApiService.PatchCmsV3BlogsPostsObjectIdUpdateExecute(r)
}

/*
PatchCmsV3BlogsPostsObjectIdUpdate Update a Blog Post

Sparse updates a single Blog Post object identified by the id in the path.
All the column values need not be specified. Only the that need to be modified can be specified.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Post id.
 @return ApiPatchCmsV3BlogsPostsObjectIdUpdateRequest
*/
func (a *BlogPostApiService) PatchCmsV3BlogsPostsObjectIdUpdate(ctx _context.Context, objectId string) ApiPatchCmsV3BlogsPostsObjectIdUpdateRequest {
	return ApiPatchCmsV3BlogsPostsObjectIdUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
//  @return BlogPost
func (a *BlogPostApiService) PatchCmsV3BlogsPostsObjectIdUpdateExecute(r ApiPatchCmsV3BlogsPostsObjectIdUpdateRequest) (BlogPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PatchCmsV3BlogsPostsObjectIdUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.blogPost == nil {
		return localVarReturnValue, nil, reportError("blogPost is required and must be specified")
	}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blogPost
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsPostsBatchArchiveArchiveBatchRequest struct {
	ctx              _context.Context
	ApiService       *BlogPostApiService
	batchInputString *BatchInputString
}

// The JSON array of Blog Post ids.
func (r ApiPostCmsV3BlogsPostsBatchArchiveArchiveBatchRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3BlogsPostsBatchArchiveArchiveBatchRequest {
	r.batchInputString = &batchInputString
	return r
}

func (r ApiPostCmsV3BlogsPostsBatchArchiveArchiveBatchRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsPostsBatchArchiveArchiveBatchExecute(r)
}

/*
PostCmsV3BlogsPostsBatchArchiveArchiveBatch Archive a batch of Blog Posts

Delete the Blog Post objects identified in the request body.
Note: This is not the same as the in-app `archive` function. To perform an in-app `archive` send an normal update with the `archived` field set to true.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsPostsBatchArchiveArchiveBatchRequest
*/
func (a *BlogPostApiService) PostCmsV3BlogsPostsBatchArchiveArchiveBatch(ctx _context.Context) ApiPostCmsV3BlogsPostsBatchArchiveArchiveBatchRequest {
	return ApiPostCmsV3BlogsPostsBatchArchiveArchiveBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *BlogPostApiService) PostCmsV3BlogsPostsBatchArchiveArchiveBatchExecute(r ApiPostCmsV3BlogsPostsBatchArchiveArchiveBatchRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PostCmsV3BlogsPostsBatchArchiveArchiveBatch")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/batch/archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.batchInputString == nil {
		return nil, reportError("batchInputString is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsPostsBatchCreateCreateBatchRequest struct {
	ctx                _context.Context
	ApiService         *BlogPostApiService
	batchInputBlogPost *BatchInputBlogPost
}

// The JSON array of new Blog Posts to create.
func (r ApiPostCmsV3BlogsPostsBatchCreateCreateBatchRequest) BatchInputBlogPost(batchInputBlogPost BatchInputBlogPost) ApiPostCmsV3BlogsPostsBatchCreateCreateBatchRequest {
	r.batchInputBlogPost = &batchInputBlogPost
	return r
}

func (r ApiPostCmsV3BlogsPostsBatchCreateCreateBatchRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsPostsBatchCreateCreateBatchExecute(r)
}

/*
PostCmsV3BlogsPostsBatchCreateCreateBatch Create a batch of Blog Posts

Create the Blog Post objects detailed in the request body.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsPostsBatchCreateCreateBatchRequest
*/
func (a *BlogPostApiService) PostCmsV3BlogsPostsBatchCreateCreateBatch(ctx _context.Context) ApiPostCmsV3BlogsPostsBatchCreateCreateBatchRequest {
	return ApiPostCmsV3BlogsPostsBatchCreateCreateBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlogPostApiService) PostCmsV3BlogsPostsBatchCreateCreateBatchExecute(r ApiPostCmsV3BlogsPostsBatchCreateCreateBatchRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PostCmsV3BlogsPostsBatchCreateCreateBatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/batch/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.batchInputBlogPost == nil {
		return localVarReturnValue, nil, reportError("batchInputBlogPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputBlogPost
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsPostsBatchReadReadBatchRequest struct {
	ctx              _context.Context
	ApiService       *BlogPostApiService
	batchInputString *BatchInputString
	archived         *bool
}

// The JSON array of Blog Post ids.
func (r ApiPostCmsV3BlogsPostsBatchReadReadBatchRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3BlogsPostsBatchReadReadBatchRequest {
	r.batchInputString = &batchInputString
	return r
}

// Specifies whether to return archived Blog Posts. Defaults to &#x60;false&#x60;.
func (r ApiPostCmsV3BlogsPostsBatchReadReadBatchRequest) Archived(archived bool) ApiPostCmsV3BlogsPostsBatchReadReadBatchRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3BlogsPostsBatchReadReadBatchRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsPostsBatchReadReadBatchExecute(r)
}

/*
PostCmsV3BlogsPostsBatchReadReadBatch Retrieve a batch of Blog Posts

Retrieve the Blog Post objects identified in the request body.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsPostsBatchReadReadBatchRequest
*/
func (a *BlogPostApiService) PostCmsV3BlogsPostsBatchReadReadBatch(ctx _context.Context) ApiPostCmsV3BlogsPostsBatchReadReadBatchRequest {
	return ApiPostCmsV3BlogsPostsBatchReadReadBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlogPostApiService) PostCmsV3BlogsPostsBatchReadReadBatchExecute(r ApiPostCmsV3BlogsPostsBatchReadReadBatchRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PostCmsV3BlogsPostsBatchReadReadBatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/batch/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsPostsBatchUpdateUpdateBatchRequest struct {
	ctx                _context.Context
	ApiService         *BlogPostApiService
	batchInputJsonNode *BatchInputJsonNode
	archived           *bool
}

func (r ApiPostCmsV3BlogsPostsBatchUpdateUpdateBatchRequest) BatchInputJsonNode(batchInputJsonNode BatchInputJsonNode) ApiPostCmsV3BlogsPostsBatchUpdateUpdateBatchRequest {
	r.batchInputJsonNode = &batchInputJsonNode
	return r
}

// Whether to return only results that have been archived.
func (r ApiPostCmsV3BlogsPostsBatchUpdateUpdateBatchRequest) Archived(archived bool) ApiPostCmsV3BlogsPostsBatchUpdateUpdateBatchRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3BlogsPostsBatchUpdateUpdateBatchRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsPostsBatchUpdateUpdateBatchExecute(r)
}

/*
PostCmsV3BlogsPostsBatchUpdateUpdateBatch Update a batch of Blog Posts

Update the Blog Post objects identified in the request body.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsPostsBatchUpdateUpdateBatchRequest
*/
func (a *BlogPostApiService) PostCmsV3BlogsPostsBatchUpdateUpdateBatch(ctx _context.Context) ApiPostCmsV3BlogsPostsBatchUpdateUpdateBatchRequest {
	return ApiPostCmsV3BlogsPostsBatchUpdateUpdateBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BlogPostApiService) PostCmsV3BlogsPostsBatchUpdateUpdateBatchExecute(r ApiPostCmsV3BlogsPostsBatchUpdateUpdateBatchRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PostCmsV3BlogsPostsBatchUpdateUpdateBatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/batch/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.batchInputJsonNode == nil {
		return localVarReturnValue, nil, reportError("batchInputJsonNode is required and must be specified")
	}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputJsonNode
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsPostsCloneCloneRequest struct {
	ctx                      _context.Context
	ApiService               *BlogPostApiService
	contentCloneRequestVNext *ContentCloneRequestVNext
}

// The JSON representation of the ContentCloneRequest object.
func (r ApiPostCmsV3BlogsPostsCloneCloneRequest) ContentCloneRequestVNext(contentCloneRequestVNext ContentCloneRequestVNext) ApiPostCmsV3BlogsPostsCloneCloneRequest {
	r.contentCloneRequestVNext = &contentCloneRequestVNext
	return r
}

func (r ApiPostCmsV3BlogsPostsCloneCloneRequest) Execute() (BlogPost, *_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsPostsCloneCloneExecute(r)
}

/*
PostCmsV3BlogsPostsCloneClone Clone a Blog Post

Clone a Blog.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsPostsCloneCloneRequest
*/
func (a *BlogPostApiService) PostCmsV3BlogsPostsCloneClone(ctx _context.Context) ApiPostCmsV3BlogsPostsCloneCloneRequest {
	return ApiPostCmsV3BlogsPostsCloneCloneRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BlogPost
func (a *BlogPostApiService) PostCmsV3BlogsPostsCloneCloneExecute(r ApiPostCmsV3BlogsPostsCloneCloneRequest) (BlogPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PostCmsV3BlogsPostsCloneClone")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/clone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.contentCloneRequestVNext == nil {
		return localVarReturnValue, nil, reportError("contentCloneRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentCloneRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsPostsCreateRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	blogPost   *BlogPost
}

// The JSON representation of a new Blog Post.
func (r ApiPostCmsV3BlogsPostsCreateRequest) BlogPost(blogPost BlogPost) ApiPostCmsV3BlogsPostsCreateRequest {
	r.blogPost = &blogPost
	return r
}

func (r ApiPostCmsV3BlogsPostsCreateRequest) Execute() (BlogPost, *_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsPostsCreateExecute(r)
}

/*
PostCmsV3BlogsPostsCreate Create a new Blog Post

Create a new Blog Post.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsPostsCreateRequest
*/
func (a *BlogPostApiService) PostCmsV3BlogsPostsCreate(ctx _context.Context) ApiPostCmsV3BlogsPostsCreateRequest {
	return ApiPostCmsV3BlogsPostsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BlogPost
func (a *BlogPostApiService) PostCmsV3BlogsPostsCreateExecute(r ApiPostCmsV3BlogsPostsCreateRequest) (BlogPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PostCmsV3BlogsPostsCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.blogPost == nil {
		return localVarReturnValue, nil, reportError("blogPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blogPost
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsPostsObjectIdDraftPushLivePushLiveRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	objectId   string
}

func (r ApiPostCmsV3BlogsPostsObjectIdDraftPushLivePushLiveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsPostsObjectIdDraftPushLivePushLiveExecute(r)
}

/*
PostCmsV3BlogsPostsObjectIdDraftPushLivePushLive Push Blog Post draft edits live

Take any changes from the draft version of the Blog Post and apply them to the live version.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The id of the Blog Post for which it's draft will be pushed live.
 @return ApiPostCmsV3BlogsPostsObjectIdDraftPushLivePushLiveRequest
*/
func (a *BlogPostApiService) PostCmsV3BlogsPostsObjectIdDraftPushLivePushLive(ctx _context.Context, objectId string) ApiPostCmsV3BlogsPostsObjectIdDraftPushLivePushLiveRequest {
	return ApiPostCmsV3BlogsPostsObjectIdDraftPushLivePushLiveRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
func (a *BlogPostApiService) PostCmsV3BlogsPostsObjectIdDraftPushLivePushLiveExecute(r ApiPostCmsV3BlogsPostsObjectIdDraftPushLivePushLiveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PostCmsV3BlogsPostsObjectIdDraftPushLivePushLive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/{objectId}/draft/push-live"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsPostsObjectIdDraftResetResetDraftRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	objectId   string
}

func (r ApiPostCmsV3BlogsPostsObjectIdDraftResetResetDraftRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsPostsObjectIdDraftResetResetDraftExecute(r)
}

/*
PostCmsV3BlogsPostsObjectIdDraftResetResetDraft Reset the Blog Post draft to the live version

Discards any edits and resets the draft to the live version.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The id of the Blog Post for which it's draft will be reset.
 @return ApiPostCmsV3BlogsPostsObjectIdDraftResetResetDraftRequest
*/
func (a *BlogPostApiService) PostCmsV3BlogsPostsObjectIdDraftResetResetDraft(ctx _context.Context, objectId string) ApiPostCmsV3BlogsPostsObjectIdDraftResetResetDraftRequest {
	return ApiPostCmsV3BlogsPostsObjectIdDraftResetResetDraftRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
func (a *BlogPostApiService) PostCmsV3BlogsPostsObjectIdDraftResetResetDraftExecute(r ApiPostCmsV3BlogsPostsObjectIdDraftResetResetDraftRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PostCmsV3BlogsPostsObjectIdDraftResetResetDraft")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/{objectId}/draft/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	objectId   string
	revisionId string
}

func (r ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest) Execute() (BlogPost, *_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionExecute(r)
}

/*
PostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreRestorePreviousVersion Restore a previous version of a blog post

Takes a specified version of a blog post and restores it.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Post id.
 @param revisionId The Blog Post version id to restore.
 @return ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest
*/
func (a *BlogPostApiService) PostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreRestorePreviousVersion(ctx _context.Context, objectId string, revisionId string) ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest {
	return ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return BlogPost
func (a *BlogPostApiService) PostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionExecute(r ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest) (BlogPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreRestorePreviousVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/{objectId}/revisions/{revisionId}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", _neturl.PathEscape(parameterToString(r.revisionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest struct {
	ctx        _context.Context
	ApiService *BlogPostApiService
	objectId   string
	revisionId int64
}

func (r ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest) Execute() (BlogPost, *_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftExecute(r)
}

/*
PostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraft Restore a previous version of a blog post, to the draft version of the blog post

Takes a specified version of a blog post, sets it as the new draft version of the blog post.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Post id.
 @param revisionId The Blog Post version id to restore.
 @return ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest
*/
func (a *BlogPostApiService) PostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraft(ctx _context.Context, objectId string, revisionId int64) ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest {
	return ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return BlogPost
func (a *BlogPostApiService) PostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftExecute(r ApiPostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest) (BlogPost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PostCmsV3BlogsPostsObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraft")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/{objectId}/revisions/{revisionId}/restore-to-draft"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", _neturl.PathEscape(parameterToString(r.revisionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsPostsScheduleScheduleRequest struct {
	ctx                         _context.Context
	ApiService                  *BlogPostApiService
	contentScheduleRequestVNext *ContentScheduleRequestVNext
}

// The JSON representation of the ContentCloneRequestVNext object.
func (r ApiPostCmsV3BlogsPostsScheduleScheduleRequest) ContentScheduleRequestVNext(contentScheduleRequestVNext ContentScheduleRequestVNext) ApiPostCmsV3BlogsPostsScheduleScheduleRequest {
	r.contentScheduleRequestVNext = &contentScheduleRequestVNext
	return r
}

func (r ApiPostCmsV3BlogsPostsScheduleScheduleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsPostsScheduleScheduleExecute(r)
}

/*
PostCmsV3BlogsPostsScheduleSchedule Schedule a Blog Post to be Published

Schedule a Blog Post to be Published.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsPostsScheduleScheduleRequest
*/
func (a *BlogPostApiService) PostCmsV3BlogsPostsScheduleSchedule(ctx _context.Context) ApiPostCmsV3BlogsPostsScheduleScheduleRequest {
	return ApiPostCmsV3BlogsPostsScheduleScheduleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *BlogPostApiService) PostCmsV3BlogsPostsScheduleScheduleExecute(r ApiPostCmsV3BlogsPostsScheduleScheduleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.PostCmsV3BlogsPostsScheduleSchedule")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/posts/schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.contentScheduleRequestVNext == nil {
		return nil, reportError("contentScheduleRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentScheduleRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
