/*
Blog Post endpoints

\"Use these endpoints for interacting with Blog Posts, Blog Authors, and Blog Tags\"

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tags

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"

	"github.com/clarkmcc/go-hubspot/authorization"
	_neturl "net/url"
	"reflect"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// TagApiService TagApi service
type TagApiService service

type ApiDeleteCmsV3BlogsTagsObjectIdArchiveRequest struct {
	ctx        _context.Context
	ApiService *TagApiService
	objectId   string
	archived   *bool
}

// Whether to return only results that have been archived.
func (r ApiDeleteCmsV3BlogsTagsObjectIdArchiveRequest) Archived(archived bool) ApiDeleteCmsV3BlogsTagsObjectIdArchiveRequest {
	r.archived = &archived
	return r
}

func (r ApiDeleteCmsV3BlogsTagsObjectIdArchiveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteCmsV3BlogsTagsObjectIdArchiveExecute(r)
}

/*
DeleteCmsV3BlogsTagsObjectIdArchive Delete a Blog Tag

Delete the Blog Tag object identified by the id in the path.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Tag id.
 @return ApiDeleteCmsV3BlogsTagsObjectIdArchiveRequest
*/
func (a *TagApiService) DeleteCmsV3BlogsTagsObjectIdArchive(ctx _context.Context, objectId string) ApiDeleteCmsV3BlogsTagsObjectIdArchiveRequest {
	return ApiDeleteCmsV3BlogsTagsObjectIdArchiveRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
func (a *TagApiService) DeleteCmsV3BlogsTagsObjectIdArchiveExecute(r ApiDeleteCmsV3BlogsTagsObjectIdArchiveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagApiService.DeleteCmsV3BlogsTagsObjectIdArchive")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/tags/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogsTagsGetPageRequest struct {
	ctx           _context.Context
	ApiService    *TagApiService
	createdAt     *time.Time
	createdAfter  *time.Time
	createdBefore *time.Time
	updatedAt     *time.Time
	updatedAfter  *time.Time
	updatedBefore *time.Time
	sort          *[]string
	after         *string
	limit         *int32
	archived      *bool
}

// Only return Blog Tags created at exactly the specified time.
func (r ApiGetCmsV3BlogsTagsGetPageRequest) CreatedAt(createdAt time.Time) ApiGetCmsV3BlogsTagsGetPageRequest {
	r.createdAt = &createdAt
	return r
}

// Only return Blog Tags created after the specified time.
func (r ApiGetCmsV3BlogsTagsGetPageRequest) CreatedAfter(createdAfter time.Time) ApiGetCmsV3BlogsTagsGetPageRequest {
	r.createdAfter = &createdAfter
	return r
}

// Only return Blog Tags created before the specified time.
func (r ApiGetCmsV3BlogsTagsGetPageRequest) CreatedBefore(createdBefore time.Time) ApiGetCmsV3BlogsTagsGetPageRequest {
	r.createdBefore = &createdBefore
	return r
}

// Only return Blog Tags last updated at exactly the specified time.
func (r ApiGetCmsV3BlogsTagsGetPageRequest) UpdatedAt(updatedAt time.Time) ApiGetCmsV3BlogsTagsGetPageRequest {
	r.updatedAt = &updatedAt
	return r
}

// Only return Blog Tags last updated after the specified time.
func (r ApiGetCmsV3BlogsTagsGetPageRequest) UpdatedAfter(updatedAfter time.Time) ApiGetCmsV3BlogsTagsGetPageRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Only return Blog Tags last updated before the specified time.
func (r ApiGetCmsV3BlogsTagsGetPageRequest) UpdatedBefore(updatedBefore time.Time) ApiGetCmsV3BlogsTagsGetPageRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Specifies which fields to use for sorting results. Valid fields are &#x60;name&#x60;, &#x60;createdAt&#x60;, &#x60;updatedAt&#x60;, &#x60;createdBy&#x60;, &#x60;updatedBy&#x60;. &#x60;createdAt&#x60; will be used by default.
func (r ApiGetCmsV3BlogsTagsGetPageRequest) Sort(sort []string) ApiGetCmsV3BlogsTagsGetPageRequest {
	r.sort = &sort
	return r
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3BlogsTagsGetPageRequest) After(after string) ApiGetCmsV3BlogsTagsGetPageRequest {
	r.after = &after
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3BlogsTagsGetPageRequest) Limit(limit int32) ApiGetCmsV3BlogsTagsGetPageRequest {
	r.limit = &limit
	return r
}

// Specifies whether to return archived Blog Tags. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3BlogsTagsGetPageRequest) Archived(archived bool) ApiGetCmsV3BlogsTagsGetPageRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3BlogsTagsGetPageRequest) Execute() (CollectionResponseWithTotalTagForwardPaging, *_nethttp.Response, error) {
	return r.ApiService.GetCmsV3BlogsTagsGetPageExecute(r)
}

/*
GetCmsV3BlogsTagsGetPage Get all Blog Tags

Get the list of blog tags. Supports paging and filtering. This method would be useful for an integration that examined these models and used an external service to suggest edits.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCmsV3BlogsTagsGetPageRequest
*/
func (a *TagApiService) GetCmsV3BlogsTagsGetPage(ctx _context.Context) ApiGetCmsV3BlogsTagsGetPageRequest {
	return ApiGetCmsV3BlogsTagsGetPageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalTagForwardPaging
func (a *TagApiService) GetCmsV3BlogsTagsGetPageExecute(r ApiGetCmsV3BlogsTagsGetPageRequest) (CollectionResponseWithTotalTagForwardPaging, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CollectionResponseWithTotalTagForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagApiService.GetCmsV3BlogsTagsGetPage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.createdAt != nil {
		localVarQueryParams.Add("createdAt", parameterToString(*r.createdAt, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.updatedAt != nil {
		localVarQueryParams.Add("updatedAt", parameterToString(*r.updatedAt, ""))
	}
	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.updatedBefore != nil {
		localVarQueryParams.Add("updatedBefore", parameterToString(*r.updatedBefore, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.after != nil {
		localVarQueryParams.Add("after", parameterToString(*r.after, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogsTagsObjectIdGetByIdRequest struct {
	ctx        _context.Context
	ApiService *TagApiService
	objectId   string
	archived   *bool
}

// Specifies whether to return archived Blog Tags. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3BlogsTagsObjectIdGetByIdRequest) Archived(archived bool) ApiGetCmsV3BlogsTagsObjectIdGetByIdRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3BlogsTagsObjectIdGetByIdRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.GetCmsV3BlogsTagsObjectIdGetByIdExecute(r)
}

/*
GetCmsV3BlogsTagsObjectIdGetById Retrieve a Blog Tag

Retrieve the Blog Tag object identified by the id in the path.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Tag id.
 @return ApiGetCmsV3BlogsTagsObjectIdGetByIdRequest
*/
func (a *TagApiService) GetCmsV3BlogsTagsObjectIdGetById(ctx _context.Context, objectId string) ApiGetCmsV3BlogsTagsObjectIdGetByIdRequest {
	return ApiGetCmsV3BlogsTagsObjectIdGetByIdRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
//  @return Tag
func (a *TagApiService) GetCmsV3BlogsTagsObjectIdGetByIdExecute(r ApiGetCmsV3BlogsTagsObjectIdGetByIdRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagApiService.GetCmsV3BlogsTagsObjectIdGetById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/tags/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCmsV3BlogsTagsObjectIdUpdateRequest struct {
	ctx        _context.Context
	ApiService *TagApiService
	objectId   string
	tag        *Tag
	archived   *bool
}

// The JSON representation of the updated Blog Tag.
func (r ApiPatchCmsV3BlogsTagsObjectIdUpdateRequest) Tag(tag Tag) ApiPatchCmsV3BlogsTagsObjectIdUpdateRequest {
	r.tag = &tag
	return r
}

// Specifies whether to update archived Blog Tags. Defaults to &#x60;false&#x60;.
func (r ApiPatchCmsV3BlogsTagsObjectIdUpdateRequest) Archived(archived bool) ApiPatchCmsV3BlogsTagsObjectIdUpdateRequest {
	r.archived = &archived
	return r
}

func (r ApiPatchCmsV3BlogsTagsObjectIdUpdateRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.PatchCmsV3BlogsTagsObjectIdUpdateExecute(r)
}

/*
PatchCmsV3BlogsTagsObjectIdUpdate Update a Blog Tag

Sparse updates a single Blog Tag object identified by the id in the path.
All the column values need not be specified. Only the that need to be modified can be specified.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Tag id.
 @return ApiPatchCmsV3BlogsTagsObjectIdUpdateRequest
*/
func (a *TagApiService) PatchCmsV3BlogsTagsObjectIdUpdate(ctx _context.Context, objectId string) ApiPatchCmsV3BlogsTagsObjectIdUpdateRequest {
	return ApiPatchCmsV3BlogsTagsObjectIdUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
//  @return Tag
func (a *TagApiService) PatchCmsV3BlogsTagsObjectIdUpdateExecute(r ApiPatchCmsV3BlogsTagsObjectIdUpdateRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagApiService.PatchCmsV3BlogsTagsObjectIdUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/tags/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", _neturl.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsTagsBatchArchiveArchiveBatchRequest struct {
	ctx              _context.Context
	ApiService       *TagApiService
	batchInputString *BatchInputString
}

// The JSON array of Blog Tag ids.
func (r ApiPostCmsV3BlogsTagsBatchArchiveArchiveBatchRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3BlogsTagsBatchArchiveArchiveBatchRequest {
	r.batchInputString = &batchInputString
	return r
}

func (r ApiPostCmsV3BlogsTagsBatchArchiveArchiveBatchRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsTagsBatchArchiveArchiveBatchExecute(r)
}

/*
PostCmsV3BlogsTagsBatchArchiveArchiveBatch Archive a batch of Blog Tags

Delete the Blog Tag objects identified in the request body.
Note: This is not the same as the in-app `archive` function.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsTagsBatchArchiveArchiveBatchRequest
*/
func (a *TagApiService) PostCmsV3BlogsTagsBatchArchiveArchiveBatch(ctx _context.Context) ApiPostCmsV3BlogsTagsBatchArchiveArchiveBatchRequest {
	return ApiPostCmsV3BlogsTagsBatchArchiveArchiveBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *TagApiService) PostCmsV3BlogsTagsBatchArchiveArchiveBatchExecute(r ApiPostCmsV3BlogsTagsBatchArchiveArchiveBatchRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagApiService.PostCmsV3BlogsTagsBatchArchiveArchiveBatch")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/tags/batch/archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.batchInputString == nil {
		return nil, reportError("batchInputString is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsTagsBatchCreateCreateBatchRequest struct {
	ctx           _context.Context
	ApiService    *TagApiService
	batchInputTag *BatchInputTag
}

// The JSON array of new Blog Tags to create.
func (r ApiPostCmsV3BlogsTagsBatchCreateCreateBatchRequest) BatchInputTag(batchInputTag BatchInputTag) ApiPostCmsV3BlogsTagsBatchCreateCreateBatchRequest {
	r.batchInputTag = &batchInputTag
	return r
}

func (r ApiPostCmsV3BlogsTagsBatchCreateCreateBatchRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsTagsBatchCreateCreateBatchExecute(r)
}

/*
PostCmsV3BlogsTagsBatchCreateCreateBatch Create a batch of Blog Tags

Create the Blog Tag objects detailed in the request body.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsTagsBatchCreateCreateBatchRequest
*/
func (a *TagApiService) PostCmsV3BlogsTagsBatchCreateCreateBatch(ctx _context.Context) ApiPostCmsV3BlogsTagsBatchCreateCreateBatchRequest {
	return ApiPostCmsV3BlogsTagsBatchCreateCreateBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TagApiService) PostCmsV3BlogsTagsBatchCreateCreateBatchExecute(r ApiPostCmsV3BlogsTagsBatchCreateCreateBatchRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagApiService.PostCmsV3BlogsTagsBatchCreateCreateBatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/tags/batch/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.batchInputTag == nil {
		return localVarReturnValue, nil, reportError("batchInputTag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputTag
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsTagsBatchReadReadBatchRequest struct {
	ctx              _context.Context
	ApiService       *TagApiService
	batchInputString *BatchInputString
	archived         *bool
}

// The JSON array of Blog Tag ids.
func (r ApiPostCmsV3BlogsTagsBatchReadReadBatchRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3BlogsTagsBatchReadReadBatchRequest {
	r.batchInputString = &batchInputString
	return r
}

// Specifies whether to return archived Blog Tags. Defaults to &#x60;false&#x60;.
func (r ApiPostCmsV3BlogsTagsBatchReadReadBatchRequest) Archived(archived bool) ApiPostCmsV3BlogsTagsBatchReadReadBatchRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3BlogsTagsBatchReadReadBatchRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsTagsBatchReadReadBatchExecute(r)
}

/*
PostCmsV3BlogsTagsBatchReadReadBatch Retrieve a batch of Blog Tags

Retrieve the Blog Tag objects identified in the request body.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsTagsBatchReadReadBatchRequest
*/
func (a *TagApiService) PostCmsV3BlogsTagsBatchReadReadBatch(ctx _context.Context) ApiPostCmsV3BlogsTagsBatchReadReadBatchRequest {
	return ApiPostCmsV3BlogsTagsBatchReadReadBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TagApiService) PostCmsV3BlogsTagsBatchReadReadBatchExecute(r ApiPostCmsV3BlogsTagsBatchReadReadBatchRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagApiService.PostCmsV3BlogsTagsBatchReadReadBatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/tags/batch/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsTagsBatchUpdateUpdateBatchRequest struct {
	ctx                _context.Context
	ApiService         *TagApiService
	batchInputJsonNode *BatchInputJsonNode
	archived           *bool
}

// A JSON array of the JSON representations of the updated Blog Tags.
func (r ApiPostCmsV3BlogsTagsBatchUpdateUpdateBatchRequest) BatchInputJsonNode(batchInputJsonNode BatchInputJsonNode) ApiPostCmsV3BlogsTagsBatchUpdateUpdateBatchRequest {
	r.batchInputJsonNode = &batchInputJsonNode
	return r
}

// Specifies whether to update archived Blog Tags. Defaults to &#x60;false&#x60;.
func (r ApiPostCmsV3BlogsTagsBatchUpdateUpdateBatchRequest) Archived(archived bool) ApiPostCmsV3BlogsTagsBatchUpdateUpdateBatchRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3BlogsTagsBatchUpdateUpdateBatchRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsTagsBatchUpdateUpdateBatchExecute(r)
}

/*
PostCmsV3BlogsTagsBatchUpdateUpdateBatch Update a batch of Blog Tags

Update the Blog Tag objects identified in the request body.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsTagsBatchUpdateUpdateBatchRequest
*/
func (a *TagApiService) PostCmsV3BlogsTagsBatchUpdateUpdateBatch(ctx _context.Context) ApiPostCmsV3BlogsTagsBatchUpdateUpdateBatchRequest {
	return ApiPostCmsV3BlogsTagsBatchUpdateUpdateBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TagApiService) PostCmsV3BlogsTagsBatchUpdateUpdateBatchExecute(r ApiPostCmsV3BlogsTagsBatchUpdateUpdateBatchRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagApiService.PostCmsV3BlogsTagsBatchUpdateUpdateBatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/tags/batch/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.batchInputJsonNode == nil {
		return localVarReturnValue, nil, reportError("batchInputJsonNode is required and must be specified")
	}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputJsonNode
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsTagsCreateRequest struct {
	ctx        _context.Context
	ApiService *TagApiService
	tag        *Tag
}

// The JSON representation of a new Blog Tag.
func (r ApiPostCmsV3BlogsTagsCreateRequest) Tag(tag Tag) ApiPostCmsV3BlogsTagsCreateRequest {
	r.tag = &tag
	return r
}

func (r ApiPostCmsV3BlogsTagsCreateRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.PostCmsV3BlogsTagsCreateExecute(r)
}

/*
PostCmsV3BlogsTagsCreate Create a new Blog Tag

Create a new Blog Tag.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsTagsCreateRequest
*/
func (a *TagApiService) PostCmsV3BlogsTagsCreate(ctx _context.Context) ApiPostCmsV3BlogsTagsCreateRequest {
	return ApiPostCmsV3BlogsTagsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Tag
func (a *TagApiService) PostCmsV3BlogsTagsCreateExecute(r ApiPostCmsV3BlogsTagsCreateRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagApiService.PostCmsV3BlogsTagsCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(authorization.ContextAPIKeys).(map[string]authorization.APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
